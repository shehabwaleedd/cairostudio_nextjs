"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router-dom";
exports.ids = ["vendor-chunks/react-router-dom"];
exports.modules = {

/***/ "(ssr)/../../../node_modules/react-router-dom/dist/index.js":
/*!************************************************************!*\
  !*** ../../../node_modules/react-router-dom/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Await),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.MemoryRouter),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Outlet),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Router),\n/* harmony export */   RouterProvider: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Routes),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext),\n/* harmony export */   UNSAFE_useRouteId: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_useRouteId),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   unstable_useBlocker: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.unstable_useBlocker),\n/* harmony export */   unstable_usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router */ \"(ssr)/../../../node_modules/react-router/dist/index.js\");\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"(ssr)/../../../node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router DOM v6.11.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */ function createSearchParams(init) {\n    if (init === void 0) {\n        init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key)=>{\n        let value = init[key];\n        return memo.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        for (let key of defaultSearchParams.keys()){\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach((value)=>{\n                    searchParams.append(key, value);\n                });\n            }\n        }\n    }\n    return searchParams;\n}\nfunction getFormSubmissionInfo(target, options, basename) {\n    let method;\n    let action = null;\n    let encType;\n    let formData;\n    if (isFormElement(target)) {\n        let submissionTrigger = options.submissionTrigger;\n        if (options.action) {\n            action = options.action;\n        } else {\n            // When grabbing the action from the element, it will have had the basename\n            // prefixed to ensure non-JS scenarios work, so strip it since we'll\n            // re-prefix in the router\n            let attr = target.getAttribute(\"action\");\n            action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(attr, basename) : null;\n        }\n        method = options.method || target.getAttribute(\"method\") || defaultMethod;\n        encType = options.encType || target.getAttribute(\"enctype\") || defaultEncType;\n        formData = new FormData(target);\n        if (submissionTrigger && submissionTrigger.name) {\n            formData.append(submissionTrigger.name, submissionTrigger.value);\n        }\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) {\n            throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n        } // <button>/<input type=\"submit\"> may override attributes of <form>\n        if (options.action) {\n            action = options.action;\n        } else {\n            // When grabbing the action from the element, it will have had the basename\n            // prefixed to ensure non-JS scenarios work, so strip it since we'll\n            // re-prefix in the router\n            let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n            action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(attr, basename) : null;\n        }\n        method = options.method || target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = options.encType || target.getAttribute(\"formenctype\") || form.getAttribute(\"enctype\") || defaultEncType;\n        formData = new FormData(form); // Include name + value from a <button>, appending in case the button name\n        // matches an existing input name\n        if (target.name) {\n            formData.append(target.name, target.value);\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + '<input type=\"submit|image\">');\n    } else {\n        method = options.method || defaultMethod;\n        action = options.action || null;\n        encType = options.encType || defaultEncType;\n        if (target instanceof FormData) {\n            formData = target;\n        } else {\n            formData = new FormData();\n            if (target instanceof URLSearchParams) {\n                for (let [name, value] of target){\n                    formData.append(name, value);\n                }\n            } else if (target != null) {\n                for (let name of Object.keys(target)){\n                    formData.append(name, target[name]);\n                }\n            }\n        }\n    }\n    return {\n        action,\n        method: method.toLowerCase(),\n        encType,\n        formData\n    };\n}\nconst _excluded = [\n    \"onClick\",\n    \"relative\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"target\",\n    \"to\",\n    \"preventScrollReset\"\n], _excluded2 = [\n    \"aria-current\",\n    \"caseSensitive\",\n    \"className\",\n    \"end\",\n    \"style\",\n    \"to\",\n    \"children\"\n], _excluded3 = [\n    \"reloadDocument\",\n    \"replace\",\n    \"method\",\n    \"action\",\n    \"onSubmit\",\n    \"fetcherKey\",\n    \"routeId\",\n    \"relative\",\n    \"preventScrollReset\"\n];\nfunction createBrowserRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_mapRouteProperties\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_mapRouteProperties\n    }).initialize();\n}\nfunction parseHydrationData() {\n    var _window;\n    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = _extends({}, state, {\n            errors: deserializeErrors(state.errors)\n        });\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        // Hey you!  If you change this, please change the corresponding logic in\n        // serializeErrors in react-router-dom/server.tsx :)\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_1__.ErrorResponse(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            let error = new Error(val.message); // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don't serialize SSR stack traces for security reasons\n            error.stack = \"\";\n            serialized[key] = error;\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */ function BrowserRouter(_ref) {\n    let { basename, children, window: window1 } = _ref;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */ function HashRouter(_ref2) {\n    let { basename, children, window: window1 } = _ref2;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createHashHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */ function HistoryRouter(_ref3) {\n    let { basename, children, history } = _ref3;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_2__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nif (true) {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser =  false && 0;\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware <a>.\n */ const Link = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref4, ref) {\n    let { onClick, relative, reloadDocument, replace, state, target, to, preventScrollReset } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext); // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n        // Render the absolute href server- and client-side\n        absoluteHref = to; // Only check for external origins client-side\n        if (isBrowser) {\n            try {\n                let currentUrl = new URL(window.location.href);\n                let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                let path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    // Strip the protocol/origin/basename for same-origin absolute URLs\n                    to = path + targetUrl.search + targetUrl.hash;\n                } else {\n                    isExternal = true;\n                }\n            } catch (e) {\n                // We can't do external URL detection without a valid URL\n                 true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, '<Link to=\"' + to + '\"> contains an invalid URL which will probably break ' + \"when clicked - please update to a valid URL path.\") : 0;\n            }\n        }\n    } // Rendered into <a href> for relative URLs\n    let href = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useHref)(to, {\n        relative\n    });\n    let internalOnClick = useLinkClickHandler(to, {\n        replace,\n        state,\n        target,\n        preventScrollReset,\n        relative\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n    })));\n});\nif (true) {\n    Link.displayName = \"Link\";\n}\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */ const NavLink = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref5, ref) {\n    let { \"aria-current\": ariaCurrentProp = \"page\", caseSensitive = false, className: classNameProp = \"\", end = false, style: styleProp, to, children } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {\n        relative: rest.relative\n    });\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);\n    let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    let className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp({\n            isActive,\n            isPending\n        });\n    } else {\n        // If the className prop is not a function, we use a default `active`\n        // class for <NavLink />s that are active. In v5 `active` was the default\n        // value for `activeClassName`, but we are removing that API and can still\n        // use the old default behavior for a cleaner upgrade path and keep the\n        // simple styling rules working as they currently do.\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp({\n        isActive,\n        isPending\n    }) : styleProp;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\n        \"aria-current\": ariaCurrent,\n        className: className,\n        ref: ref,\n        style: style,\n        to: to\n    }), typeof children === \"function\" ? children({\n        isActive,\n        isPending\n    }) : children);\n});\nif (true) {\n    NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */ const Form = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {\n        ref: ref\n    }));\n});\nif (true) {\n    Form.displayName = \"Form\";\n}\nconst FormImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref6, forwardedRef)=>{\n    let { reloadDocument, replace, method = defaultMethod, action, onSubmit, fetcherKey, routeId, relative, preventScrollReset } = _ref6, props = _objectWithoutPropertiesLoose(_ref6, _excluded3);\n    let submit = useSubmitImpl(fetcherKey, routeId);\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let formAction = useFormAction(action, {\n        relative\n    });\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n        submit(submitter || event.currentTarget, {\n            method: submitMethod,\n            replace,\n            relative,\n            preventScrollReset\n        });\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", _extends({\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n});\nif (true) {\n    FormImpl.displayName = \"FormImpl\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */ function ScrollRestoration(_ref7) {\n    let { getKey, storageKey } = _ref7;\n    useScrollRestoration({\n        getKey,\n        storageKey\n    });\n    return null;\n}\nif (true) {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n} //#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmitImpl\"] = \"useSubmitImpl\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterContext);\n    !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_DataRouterStateContext);\n    !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */ function useLinkClickHandler(to, _temp) {\n    let { target, replace: replaceProp, state, preventScrollReset, relative } = _temp === void 0 ? {} : _temp;\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(to, {\n        relative\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>{\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of\n            // a push, so do the same here unless the replace prop is explicitly set\n            let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);\n            navigate(to, {\n                replace,\n                state,\n                preventScrollReset,\n                relative\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative\n    ]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */ function useSearchParams(defaultInit) {\n     true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : 0;\n    let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>// Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigate)();\n    let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */ function useSubmit() {\n    return useSubmitImpl();\n}\nfunction useSubmitImpl(fetcherKey, fetcherRouteId) {\n    let { router } = useDataRouterContext(DataRouterHook.UseSubmitImpl);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\n    let currentRouteId = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_useRouteId)();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        if (typeof document === \"undefined\") {\n            throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n        }\n        let { action, method, encType, formData } = getFormSubmissionInfo(target, options, basename); // Base options shared between fetch() and navigate()\n        let opts = {\n            preventScrollReset: options.preventScrollReset,\n            formData,\n            formMethod: method,\n            formEncType: encType\n        };\n        if (fetcherKey) {\n            !(fetcherRouteId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"No routeId available for useFetcher()\") : 0 : void 0;\n            router.fetch(fetcherKey, fetcherRouteId, action, opts);\n        } else {\n            router.navigate(action, _extends({}, opts, {\n                replace: options.replace,\n                fromRouteId: currentRouteId\n            }));\n        }\n    }, [\n        router,\n        basename,\n        fetcherKey,\n        fetcherRouteId,\n        currentRouteId\n    ]);\n} // v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_NavigationContext);\n    let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);\n    !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"useFormAction must be used inside a RouteContext\") : 0 : void 0;\n    let [match] = routeContext.matches.slice(-1); // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useResolvedPath)(action ? action : \".\", {\n        relative\n    })); // Previously we set the default action to \".\". The problem with this is that\n    // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\n    // URL. This is the intended behavior of when \".\" is specifically provided as\n    // the form action, but inconsistent w/ browsers when the action is omitted.\n    // https://github.com/remix-run/remix/issues/927\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    if (action == null) {\n        // Safe to write to these directly here since if action was undefined, we\n        // would have called useResolvedPath(\".\") which will never include a search\n        // or hash\n        path.search = location.search;\n        path.hash = location.hash; // When grabbing search params from the URL, remove the automatically\n        // inserted ?index param so we match the useResolvedPath search behavior\n        // which would not include ?index\n        if (match.route.index) {\n            let params = new URLSearchParams(path.search);\n            params.delete(\"index\");\n            path.search = params.toString() ? \"?\" + params.toString() : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    } // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n            basename,\n            path.pathname\n        ]);\n    }\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_1__.createPath)(path);\n}\nfunction createFetcherForm(fetcherKey, routeId) {\n    let FetcherForm = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, _extends({}, props, {\n            ref: ref,\n            fetcherKey: fetcherKey,\n            routeId: routeId\n        }));\n    });\n    if (true) {\n        FetcherForm.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm;\n}\nlet fetcherId = 0;\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */ function useFetcher() {\n    var _route$matches;\n    let { router } = useDataRouterContext(DataRouterHook.UseFetcher);\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_RouteContext);\n    !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"useFetcher must be used inside a RouteContext\") : 0 : void 0;\n    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, 'useFetcher can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    let [fetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>String(++fetcherId));\n    let [Form] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"No routeId available for fetcher.Form()\") : 0 : void 0;\n        return createFetcherForm(fetcherKey, routeId);\n    });\n    let [load] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>(href)=>{\n            !router ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"No router available for fetcher.load()\") : 0 : void 0;\n            !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"No routeId available for fetcher.load()\") : 0 : void 0;\n            router.fetch(fetcherKey, routeId, href);\n        });\n    let submit = useSubmitImpl(fetcherKey, routeId);\n    let fetcher = router.getFetcher(fetcherKey);\n    let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>_extends({\n            Form,\n            submit,\n            load\n        }, fetcher), [\n        fetcher,\n        Form,\n        submit,\n        load\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Is this busted when the React team gets real weird and calls effects\n        // twice on mount?  We really just need to garbage collect here when this\n        // fetcher is no longer around.\n        return ()=>{\n            if (!router) {\n                console.warn(\"No router available to clean up from useFetcher()\");\n                return;\n            }\n            router.deleteFetcher(fetcherKey);\n        };\n    }, [\n        router,\n        fetcherKey\n    ]);\n    return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */ function useFetchers() {\n    let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return [\n        ...state.fetchers.values()\n    ];\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */ function useScrollRestoration(_temp3) {\n    let { getKey, storageKey } = _temp3 === void 0 ? {} : _temp3;\n    let { router } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n    let { restoreScrollPosition, preventScrollReset } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useLocation)();\n    let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useMatches)();\n    let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.useNavigation)(); // Trigger manual scroll restoration while we're active\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []); // Save positions on pagehide\n    usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = (getKey ? getKey(location, matches) : null) || location.key;\n            savedScrollPositions[key] = window.scrollY;\n        }\n        sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        storageKey,\n        getKey,\n        navigation.state,\n        location,\n        matches\n    ])); // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            } catch (e) {}\n        }, [\n            storageKey\n        ]); // Enable scroll restoration in the router\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, getKey);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            getKey\n        ]); // Restore scrolling when state.restoreScrollPosition changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            // Explicit false means don't do anything (used for submissions)\n            if (restoreScrollPosition === false) {\n                return;\n            } // been here before, scroll to it\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            } // try to scroll to the hash\n            if (location.hash) {\n                let el = document.getElementById(location.hash.slice(1));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            } // Don't reset if this navigation opted out\n            if (preventScrollReset === true) {\n                return;\n            } // otherwise go to the top on new locations\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function useBeforeUnload(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function usePageHide(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */ function usePrompt(_ref8) {\n    let { when, message } = _ref8;\n    let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.unstable_useBlocker)(when);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [\n        blocker,\n        when\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) {\n                setTimeout(blocker.proceed, 0);\n            } else {\n                blocker.reset();\n            }\n        }\n    }, [\n        blocker,\n        message\n    ]);\n}\n//#endregion\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUM4QjtBQUM2UTtBQUM4ZjtBQUNyb0I7QUFFckssU0FBUzZEO0lBQ1BBLFdBQVdDLE9BQU9DLE1BQU0sR0FBR0QsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLEtBQUssU0FBVUMsTUFBTTtRQUNoRSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLElBQUlHLFNBQVNGLFNBQVMsQ0FBQ0QsRUFBRTtZQUV6QixJQUFLLElBQUlJLE9BQU9ELE9BQVE7Z0JBQ3RCLElBQUlQLE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLFFBQVFDLE1BQU07b0JBQ3JETCxNQUFNLENBQUNLLElBQUksR0FBR0QsTUFBTSxDQUFDQyxJQUFJO2dCQUMzQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPTDtJQUNUO0lBQ0EsT0FBT0osU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRVA7QUFDOUI7QUFFQSxTQUFTUSw4QkFBOEJOLE1BQU0sRUFBRU8sUUFBUTtJQUNyRCxJQUFJUCxVQUFVLE1BQU0sT0FBTyxDQUFDO0lBQzVCLElBQUlKLFNBQVMsQ0FBQztJQUNkLElBQUlZLGFBQWFmLE9BQU9nQixJQUFJLENBQUNUO0lBQzdCLElBQUlDLEtBQUtKO0lBRVQsSUFBS0EsSUFBSSxHQUFHQSxJQUFJVyxXQUFXVCxNQUFNLEVBQUVGLElBQUs7UUFDdENJLE1BQU1PLFVBQVUsQ0FBQ1gsRUFBRTtRQUNuQixJQUFJVSxTQUFTRyxPQUFPLENBQUNULFFBQVEsR0FBRztRQUNoQ0wsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFB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LE9BQU87WUFDM0JBO1FBQ0YsSUFBSTdHO1FBQ0psRyxPQUFPZ04sZ0JBQWdCLENBQUMsWUFBWUYsVUFBVWxOO1FBQzlDLE9BQU87WUFDTEksT0FBT2lOLG1CQUFtQixDQUFDLFlBQVlILFVBQVVsTjtRQUNuRDtJQUNGLEdBQUc7UUFBQ2tOO1FBQVVDO0tBQVE7QUFDeEI7QUFDQTs7Ozs7OztDQU9DLEdBR0QsU0FBU0csVUFBVUMsS0FBSztJQUN0QixJQUFJLEVBQ0ZDLElBQUksRUFDSmhNLE9BQU8sRUFDUixHQUFHK0w7SUFDSixJQUFJRSxVQUFVblYsaUVBQW1CQSxDQUFDa1Y7SUFDbENoVyw0Q0FBZSxDQUFDO1FBQ2QsSUFBSWlXLFFBQVE5TSxLQUFLLEtBQUssYUFBYSxDQUFDNk0sTUFBTTtZQUN4Q0MsUUFBUUMsS0FBSztRQUNmO0lBQ0YsR0FBRztRQUFDRDtRQUFTRDtLQUFLO0lBQ2xCaFcsNENBQWUsQ0FBQztRQUNkLElBQUlpVyxRQUFROU0sS0FBSyxLQUFLLFdBQVc7WUFDL0IsSUFBSWdOLFVBQVV2TixPQUFPd04sT0FBTyxDQUFDcE07WUFFN0IsSUFBSW1NLFNBQVM7Z0JBQ1hFLFdBQVdKLFFBQVFFLE9BQU8sRUFBRTtZQUM5QixPQUFPO2dCQUNMRixRQUFRQyxLQUFLO1lBQ2Y7UUFDRjtJQUNGLEdBQUc7UUFBQ0Q7UUFBU2pNO0tBQVE7QUFDdkI7QUFDQyxZQUFZO0FBRW9XLENBQ2pYLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NhaXJvc3R1ZGlvLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2Rpc3QvaW5kZXguanM/M2EyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlYWN0IFJvdXRlciBET00gdjYuMTEuMlxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLCBSb3V0ZXIsIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCwgdXNlSHJlZiwgdXNlUmVzb2x2ZWRQYXRoLCB1c2VMb2NhdGlvbiwgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsIHVzZU5hdmlnYXRlLCBjcmVhdGVQYXRoLCBVTlNBRkVfdXNlUm91dGVJZCwgVU5TQUZFX1JvdXRlQ29udGV4dCwgdXNlTWF0Y2hlcywgdXNlTmF2aWdhdGlvbiwgdW5zdGFibGVfdXNlQmxvY2tlciwgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBd2FpdCwgTWVtb3J5Um91dGVyLCBOYXZpZ2F0ZSwgTmF2aWdhdGlvblR5cGUsIE91dGxldCwgUm91dGUsIFJvdXRlciwgUm91dGVyUHJvdmlkZXIsIFJvdXRlcywgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LCBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCwgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCwgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LCBVTlNBRkVfUm91dGVDb250ZXh0LCBVTlNBRkVfdXNlUm91dGVJZCwgY3JlYXRlTWVtb3J5Um91dGVyLCBjcmVhdGVQYXRoLCBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cywgZGVmZXIsIGdlbmVyYXRlUGF0aCwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGpzb24sIG1hdGNoUGF0aCwgbWF0Y2hSb3V0ZXMsIHBhcnNlUGF0aCwgcmVkaXJlY3QsIHJlbmRlck1hdGNoZXMsIHJlc29sdmVQYXRoLCB1bnN0YWJsZV91c2VCbG9ja2VyLCB1c2VBY3Rpb25EYXRhLCB1c2VBc3luY0Vycm9yLCB1c2VBc3luY1ZhbHVlLCB1c2VIcmVmLCB1c2VJblJvdXRlckNvbnRleHQsIHVzZUxvYWRlckRhdGEsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaCwgdXNlTWF0Y2hlcywgdXNlTmF2aWdhdGUsIHVzZU5hdmlnYXRpb24sIHVzZU5hdmlnYXRpb25UeXBlLCB1c2VPdXRsZXQsIHVzZU91dGxldENvbnRleHQsIHVzZVBhcmFtcywgdXNlUmVzb2x2ZWRQYXRoLCB1c2VSZXZhbGlkYXRvciwgdXNlUm91dGVFcnJvciwgdXNlUm91dGVMb2FkZXJEYXRhLCB1c2VSb3V0ZXMgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IHsgc3RyaXBCYXNlbmFtZSwgY3JlYXRlUm91dGVyLCBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIEVycm9yUmVzcG9uc2UsIFVOU0FGRV93YXJuaW5nLCBVTlNBRkVfaW52YXJpYW50LCBqb2luUGF0aHMgfSBmcm9tICdAcmVtaXgtcnVuL3JvdXRlcic7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmNvbnN0IGRlZmF1bHRNZXRob2QgPSBcImdldFwiO1xuY29uc3QgZGVmYXVsdEVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xufVxuZnVuY3Rpb24gaXNGb3JtRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDAgJiYgKCAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgLy8gTGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gaW5pdGlhbGl6ZXIuXG4gKlxuICogVGhpcyBpcyBpZGVudGljYWwgdG8gYG5ldyBVUkxTZWFyY2hQYXJhbXMoaW5pdClgIGV4Y2VwdCBpdCBhbHNvXG4gKiBzdXBwb3J0cyBhcnJheXMgYXMgdmFsdWVzIGluIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgaW5pdGlhbGl6ZXJcbiAqIGluc3RlYWQgb2YganVzdCBzdHJpbmdzLiBUaGlzIGlzIGNvbnZlbmllbnQgd2hlbiB5b3UgbmVlZCBtdWx0aXBsZVxuICogdmFsdWVzIGZvciBhIGdpdmVuIGtleSwgYnV0IGRvbid0IHdhbnQgdG8gdXNlIGFuIGFycmF5IGluaXRpYWxpemVyLlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoW1xuICogICAgIFsnc29ydCcsICduYW1lJ10sXG4gKiAgICAgWydzb3J0JywgJ3ByaWNlJ11cbiAqICAgXSk7XG4gKlxuICogeW91IGNhbiBkbzpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMoe1xuICogICAgIHNvcnQ6IFsnbmFtZScsICdwcmljZSddXG4gKiAgIH0pO1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtcyhpbml0KSB7XG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICBpbml0ID0gXCJcIjtcbiAgfVxuXG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHR5cGVvZiBpbml0ID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoaW5pdCkgfHwgaW5pdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyA/IGluaXQgOiBPYmplY3Qua2V5cyhpbml0KS5yZWR1Y2UoKG1lbW8sIGtleSkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IGluaXRba2V5XTtcbiAgICByZXR1cm4gbWVtby5jb25jYXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBba2V5LCB2XSkgOiBbW2tleSwgdmFsdWVdXSk7XG4gIH0sIFtdKSk7XG59XG5mdW5jdGlvbiBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvblNlYXJjaCwgZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uU2VhcmNoKTtcblxuICBpZiAoZGVmYXVsdFNlYXJjaFBhcmFtcykge1xuICAgIGZvciAobGV0IGtleSBvZiBkZWZhdWx0U2VhcmNoUGFyYW1zLmtleXMoKSkge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5nZXRBbGwoa2V5KS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKHRhcmdldCwgb3B0aW9ucywgYmFzZW5hbWUpIHtcbiAgbGV0IG1ldGhvZDtcbiAgbGV0IGFjdGlvbiA9IG51bGw7XG4gIGxldCBlbmNUeXBlO1xuICBsZXQgZm9ybURhdGE7XG5cbiAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgIGxldCBzdWJtaXNzaW9uVHJpZ2dlciA9IG9wdGlvbnMuc3VibWlzc2lvblRyaWdnZXI7XG5cbiAgICBpZiAob3B0aW9ucy5hY3Rpb24pIHtcbiAgICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIGdyYWJiaW5nIHRoZSBhY3Rpb24gZnJvbSB0aGUgZWxlbWVudCwgaXQgd2lsbCBoYXZlIGhhZCB0aGUgYmFzZW5hbWVcbiAgICAgIC8vIHByZWZpeGVkIHRvIGVuc3VyZSBub24tSlMgc2NlbmFyaW9zIHdvcmssIHNvIHN0cmlwIGl0IHNpbmNlIHdlJ2xsXG4gICAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgICAgYWN0aW9uID0gYXR0ciA/IHN0cmlwQmFzZW5hbWUoYXR0ciwgYmFzZW5hbWUpIDogbnVsbDtcbiAgICB9XG5cbiAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IG9wdGlvbnMuZW5jVHlwZSB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSh0YXJnZXQpO1xuXG4gICAgaWYgKHN1Ym1pc3Npb25UcmlnZ2VyICYmIHN1Ym1pc3Npb25UcmlnZ2VyLm5hbWUpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChzdWJtaXNzaW9uVHJpZ2dlci5uYW1lLCBzdWJtaXNzaW9uVHJpZ2dlci52YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQnV0dG9uRWxlbWVudCh0YXJnZXQpIHx8IGlzSW5wdXRFbGVtZW50KHRhcmdldCkgJiYgKHRhcmdldC50eXBlID09PSBcInN1Ym1pdFwiIHx8IHRhcmdldC50eXBlID09PSBcImltYWdlXCIpKSB7XG4gICAgbGV0IGZvcm0gPSB0YXJnZXQuZm9ybTtcblxuICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzdWJtaXQgYSA8YnV0dG9uPiBvciA8aW5wdXQgdHlwZT1cXFwic3VibWl0XFxcIj4gd2l0aG91dCBhIDxmb3JtPlwiKTtcbiAgICB9IC8vIDxidXR0b24+LzxpbnB1dCB0eXBlPVwic3VibWl0XCI+IG1heSBvdmVycmlkZSBhdHRyaWJ1dGVzIG9mIDxmb3JtPlxuXG5cbiAgICBpZiAob3B0aW9ucy5hY3Rpb24pIHtcbiAgICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIGdyYWJiaW5nIHRoZSBhY3Rpb24gZnJvbSB0aGUgZWxlbWVudCwgaXQgd2lsbCBoYXZlIGhhZCB0aGUgYmFzZW5hbWVcbiAgICAgIC8vIHByZWZpeGVkIHRvIGVuc3VyZSBub24tSlMgc2NlbmFyaW9zIHdvcmssIHNvIHN0cmlwIGl0IHNpbmNlIHdlJ2xsXG4gICAgICAvLyByZS1wcmVmaXggaW4gdGhlIHJvdXRlclxuICAgICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICAgIGFjdGlvbiA9IGF0dHIgPyBzdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XG4gICAgfVxuXG4gICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBlbmNUeXBlID0gb3B0aW9ucy5lbmNUeXBlIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSk7IC8vIEluY2x1ZGUgbmFtZSArIHZhbHVlIGZyb20gYSA8YnV0dG9uPiwgYXBwZW5kaW5nIGluIGNhc2UgdGhlIGJ1dHRvbiBuYW1lXG4gICAgLy8gbWF0Y2hlcyBhbiBleGlzdGluZyBpbnB1dCBuYW1lXG5cbiAgICBpZiAodGFyZ2V0Lm5hbWUpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCh0YXJnZXQubmFtZSwgdGFyZ2V0LnZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIFwiICsgXCI8aW5wdXQgdHlwZT1cXFwic3VibWl0fGltYWdlXFxcIj5cIik7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBvcHRpb25zLmFjdGlvbiB8fCBudWxsO1xuICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgZGVmYXVsdEVuY1R5cGU7XG5cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgIGZvcm1EYXRhID0gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgdGFyZ2V0KSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIG9mIE9iamVjdC5rZXlzKHRhcmdldCkpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdGFyZ2V0W25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWN0aW9uLFxuICAgIG1ldGhvZDogbWV0aG9kLnRvTG93ZXJDYXNlKCksXG4gICAgZW5jVHlwZSxcbiAgICBmb3JtRGF0YVxuICB9O1xufVxuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJvbkNsaWNrXCIsIFwicmVsYXRpdmVcIiwgXCJyZWxvYWREb2N1bWVudFwiLCBcInJlcGxhY2VcIiwgXCJzdGF0ZVwiLCBcInRhcmdldFwiLCBcInRvXCIsIFwicHJldmVudFNjcm9sbFJlc2V0XCJdLFxuICAgICAgX2V4Y2x1ZGVkMiA9IFtcImFyaWEtY3VycmVudFwiLCBcImNhc2VTZW5zaXRpdmVcIiwgXCJjbGFzc05hbWVcIiwgXCJlbmRcIiwgXCJzdHlsZVwiLCBcInRvXCIsIFwiY2hpbGRyZW5cIl0sXG4gICAgICBfZXhjbHVkZWQzID0gW1wicmVsb2FkRG9jdW1lbnRcIiwgXCJyZXBsYWNlXCIsIFwibWV0aG9kXCIsIFwiYWN0aW9uXCIsIFwib25TdWJtaXRcIiwgXCJmZXRjaGVyS2V5XCIsIFwicm91dGVJZFwiLCBcInJlbGF0aXZlXCIsIFwicHJldmVudFNjcm9sbFJlc2V0XCJdO1xuZnVuY3Rpb24gY3JlYXRlQnJvd3NlclJvdXRlcihyb3V0ZXMsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcih7XG4gICAgYmFzZW5hbWU6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuYmFzZW5hbWUsXG4gICAgZnV0dXJlOiBfZXh0ZW5kcyh7fSwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mdXR1cmUsIHtcbiAgICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogdHJ1ZVxuICAgIH0pLFxuICAgIGhpc3Rvcnk6IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHtcbiAgICAgIHdpbmRvdzogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy53aW5kb3dcbiAgICB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5oeWRyYXRpb25EYXRhKSB8fCBwYXJzZUh5ZHJhdGlvbkRhdGEoKSxcbiAgICByb3V0ZXMsXG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzOiBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzXG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICB9KSxcbiAgICBoaXN0b3J5OiBjcmVhdGVIYXNoSGlzdG9yeSh7XG4gICAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSkgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczogVU5TQUZFX21hcFJvdXRlUHJvcGVydGllc1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpIHtcbiAgdmFyIF93aW5kb3c7XG5cbiAgbGV0IHN0YXRlID0gKF93aW5kb3cgPSB3aW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93Ll9fc3RhdGljUm91dGVySHlkcmF0aW9uRGF0YTtcblxuICBpZiAoc3RhdGUgJiYgc3RhdGUuZXJyb3JzKSB7XG4gICAgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgIGVycm9yczogZGVzZXJpYWxpemVFcnJvcnMoc3RhdGUuZXJyb3JzKVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKCFlcnJvcnMpIHJldHVybiBudWxsO1xuICBsZXQgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGVycm9ycyk7XG4gIGxldCBzZXJpYWxpemVkID0ge307XG5cbiAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBlbnRyaWVzKSB7XG4gICAgLy8gSGV5IHlvdSEgIElmIHlvdSBjaGFuZ2UgdGhpcywgcGxlYXNlIGNoYW5nZSB0aGUgY29ycmVzcG9uZGluZyBsb2dpYyBpblxuICAgIC8vIHNlcmlhbGl6ZUVycm9ycyBpbiByZWFjdC1yb3V0ZXItZG9tL3NlcnZlci50c3ggOilcbiAgICBpZiAodmFsICYmIHZhbC5fX3R5cGUgPT09IFwiUm91dGVFcnJvclJlc3BvbnNlXCIpIHtcbiAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IG5ldyBFcnJvclJlc3BvbnNlKHZhbC5zdGF0dXMsIHZhbC5zdGF0dXNUZXh0LCB2YWwuZGF0YSwgdmFsLmludGVybmFsID09PSB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB2YWwuX190eXBlID09PSBcIkVycm9yXCIpIHtcbiAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcih2YWwubWVzc2FnZSk7IC8vIFdpcGUgYXdheSB0aGUgY2xpZW50LXNpZGUgc3RhY2sgdHJhY2UuICBOb3RoaW5nIHRvIGZpbGwgaXQgaW4gd2l0aFxuICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuXG4gICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSBlcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICovXG5cblxuZnVuY3Rpb24gQnJvd3NlclJvdXRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgd2luZG93XG4gIH0gPSBfcmVmO1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuXG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHtcbiAgICAgIHdpbmRvdyxcbiAgICAgIHY1Q29tcGF0OiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICB9KTtcbn1cbi8qKlxuICogQSBgPFJvdXRlcj5gIGZvciB1c2UgaW4gd2ViIGJyb3dzZXJzLiBTdG9yZXMgdGhlIGxvY2F0aW9uIGluIHRoZSBoYXNoXG4gKiBwb3J0aW9uIG9mIHRoZSBVUkwgc28gaXQgaXMgbm90IHNlbnQgdG8gdGhlIHNlcnZlci5cbiAqL1xuXG5mdW5jdGlvbiBIYXNoUm91dGVyKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgd2luZG93XG4gIH0gPSBfcmVmMjtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWYoKTtcblxuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7XG4gICAgICB3aW5kb3csXG4gICAgICB2NUNvbXBhdDogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgfSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICovXG5cbmZ1bmN0aW9uIEhpc3RvcnlSb3V0ZXIoX3JlZjMpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBoaXN0b3J5XG4gIH0gPSBfcmVmMztcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvblxuICB9KTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5hY3Rpb24sXG4gICAgbmF2aWdhdG9yOiBoaXN0b3J5XG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEhpc3RvcnlSb3V0ZXIuZGlzcGxheU5hbWUgPSBcInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXJcIjtcbn1cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXig/OlthLXpdW2EtejAtOSsuLV0qOnxcXC9cXC8pL2k7XG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuXG5jb25zdCBMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTGlua1dpdGhSZWYoX3JlZjQsIHJlZikge1xuICBsZXQge1xuICAgIG9uQ2xpY2ssXG4gICAgcmVsYXRpdmUsXG4gICAgcmVsb2FkRG9jdW1lbnQsXG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICB0YXJnZXQsXG4gICAgdG8sXG4gICAgcHJldmVudFNjcm9sbFJlc2V0XG4gIH0gPSBfcmVmNCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmNCwgX2V4Y2x1ZGVkKTtcblxuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7IC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIGFic29sdXRlIFVSTHNcblxuICBsZXQgYWJzb2x1dGVIcmVmO1xuICBsZXQgaXNFeHRlcm5hbCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgJiYgQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodG8pKSB7XG4gICAgLy8gUmVuZGVyIHRoZSBhYnNvbHV0ZSBocmVmIHNlcnZlci0gYW5kIGNsaWVudC1zaWRlXG4gICAgYWJzb2x1dGVIcmVmID0gdG87IC8vIE9ubHkgY2hlY2sgZm9yIGV4dGVybmFsIG9yaWdpbnMgY2xpZW50LXNpZGVcblxuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIGxldCB0YXJnZXRVcmwgPSB0by5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyB0bykgOiBuZXcgVVJMKHRvKTtcbiAgICAgICAgbGV0IHBhdGggPSBzdHJpcEJhc2VuYW1lKHRhcmdldFVybC5wYXRobmFtZSwgYmFzZW5hbWUpO1xuXG4gICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBTdHJpcCB0aGUgcHJvdG9jb2wvb3JpZ2luL2Jhc2VuYW1lIGZvciBzYW1lLW9yaWdpbiBhYnNvbHV0ZSBVUkxzXG4gICAgICAgICAgdG8gPSBwYXRoICsgdGFyZ2V0VXJsLnNlYXJjaCArIHRhcmdldFVybC5oYXNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzRXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IGRvIGV4dGVybmFsIFVSTCBkZXRlY3Rpb24gd2l0aG91dCBhIHZhbGlkIFVSTFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCI8TGluayB0bz1cXFwiXCIgKyB0byArIFwiXFxcIj4gY29udGFpbnMgYW4gaW52YWxpZCBVUkwgd2hpY2ggd2lsbCBwcm9iYWJseSBicmVhayBcIiArIFwid2hlbiBjbGlja2VkIC0gcGxlYXNlIHVwZGF0ZSB0byBhIHZhbGlkIFVSTCBwYXRoLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgcmVsYXRpdmUgVVJMc1xuXG5cbiAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG4gIGxldCBpbnRlcm5hbE9uQ2xpY2sgPSB1c2VMaW5rQ2xpY2tIYW5kbGVyKHRvLCB7XG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICB0YXJnZXQsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHJlbGF0aXZlXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuXG4gICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICBpbnRlcm5hbE9uQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgaHJlZjogYWJzb2x1dGVIcmVmIHx8IGhyZWYsXG4gICAgICBvbkNsaWNrOiBpc0V4dGVybmFsIHx8IHJlbG9hZERvY3VtZW50ID8gb25DbGljayA6IGhhbmRsZUNsaWNrLFxuICAgICAgcmVmOiByZWYsXG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH0pKVxuICApO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xufVxuLyoqXG4gKiBBIDxMaW5rPiB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xuXG5cbmNvbnN0IE5hdkxpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBOYXZMaW5rV2l0aFJlZihfcmVmNSwgcmVmKSB7XG4gIGxldCB7XG4gICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgZW5kID0gZmFsc2UsXG4gICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICB0byxcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjUsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjUsIF9leGNsdWRlZDIpO1xuXG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgcmVsYXRpdmU6IHJlc3QucmVsYXRpdmVcbiAgfSk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZXJTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIG5hdmlnYXRvclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZSA6IHBhdGgucGF0aG5hbWU7XG4gIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gIGxldCBuZXh0TG9jYXRpb25QYXRobmFtZSA9IHJvdXRlclN0YXRlICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24gJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiA/IHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24ucGF0aG5hbWUgOiBudWxsO1xuXG4gIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgbmV4dExvY2F0aW9uUGF0aG5hbWUgPSBuZXh0TG9jYXRpb25QYXRobmFtZSA/IG5leHRMb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIHRvUGF0aG5hbWUgPSB0b1BhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBsZXQgaXNBY3RpdmUgPSBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCI7XG4gIGxldCBpc1BlbmRpbmcgPSBuZXh0TG9jYXRpb25QYXRobmFtZSAhPSBudWxsICYmIChuZXh0TG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fCAhZW5kICYmIG5leHRMb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpO1xuICBsZXQgYXJpYUN1cnJlbnQgPSBpc0FjdGl2ZSA/IGFyaWFDdXJyZW50UHJvcCA6IHVuZGVmaW5lZDtcbiAgbGV0IGNsYXNzTmFtZTtcblxuICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3Aoe1xuICAgICAgaXNBY3RpdmUsXG4gICAgICBpc1BlbmRpbmdcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY2xhc3NOYW1lIHByb3AgaXMgbm90IGEgZnVuY3Rpb24sIHdlIHVzZSBhIGRlZmF1bHQgYGFjdGl2ZWBcbiAgICAvLyBjbGFzcyBmb3IgPE5hdkxpbmsgLz5zIHRoYXQgYXJlIGFjdGl2ZS4gSW4gdjUgYGFjdGl2ZWAgd2FzIHRoZSBkZWZhdWx0XG4gICAgLy8gdmFsdWUgZm9yIGBhY3RpdmVDbGFzc05hbWVgLCBidXQgd2UgYXJlIHJlbW92aW5nIHRoYXQgQVBJIGFuZCBjYW4gc3RpbGxcbiAgICAvLyB1c2UgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIGZvciBhIGNsZWFuZXIgdXBncmFkZSBwYXRoIGFuZCBrZWVwIHRoZVxuICAgIC8vIHNpbXBsZSBzdHlsaW5nIHJ1bGVzIHdvcmtpbmcgYXMgdGhleSBjdXJyZW50bHkgZG8uXG4gICAgY2xhc3NOYW1lID0gW2NsYXNzTmFtZVByb3AsIGlzQWN0aXZlID8gXCJhY3RpdmVcIiA6IG51bGwsIGlzUGVuZGluZyA/IFwicGVuZGluZ1wiIDogbnVsbF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICB9XG5cbiAgbGV0IHN0eWxlID0gdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHtcbiAgICBpc0FjdGl2ZSxcbiAgICBpc1BlbmRpbmdcbiAgfSkgOiBzdHlsZVByb3A7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50LFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIHJlZjogcmVmLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICB0bzogdG9cbiAgfSksIHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oe1xuICAgIGlzQWN0aXZlLFxuICAgIGlzUGVuZGluZ1xuICB9KSA6IGNoaWxkcmVuKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbn1cbi8qKlxuICogQSBgQHJlbWl4LXJ1bi9yb3V0ZXJgLWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHRcbiAqIHRoYXQgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIHNlcnZlciBpcyB3aXRoIGBmZXRjaGAgaW5zdGVhZCBvZiBuZXcgZG9jdW1lbnRcbiAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAqL1xuXG5cbmNvbnN0IEZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlZjogcmVmXG4gIH0pKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcbn1cblxuY29uc3QgRm9ybUltcGwgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoX3JlZjYsIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQge1xuICAgIHJlbG9hZERvY3VtZW50LFxuICAgIHJlcGxhY2UsXG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCxcbiAgICBhY3Rpb24sXG4gICAgb25TdWJtaXQsXG4gICAgZmV0Y2hlcktleSxcbiAgICByb3V0ZUlkLFxuICAgIHJlbGF0aXZlLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldFxuICB9ID0gX3JlZjYsXG4gICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY2LCBfZXhjbHVkZWQzKTtcblxuICBsZXQgc3VibWl0ID0gdXNlU3VibWl0SW1wbChmZXRjaGVyS2V5LCByb3V0ZUlkKTtcbiAgbGV0IGZvcm1NZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgbGV0IGZvcm1BY3Rpb24gPSB1c2VGb3JtQWN0aW9uKGFjdGlvbiwge1xuICAgIHJlbGF0aXZlXG4gIH0pO1xuXG4gIGxldCBzdWJtaXRIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IHN1Ym1pdHRlciA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnN1Ym1pdHRlcjtcbiAgICBsZXQgc3VibWl0TWV0aG9kID0gKHN1Ym1pdHRlciA9PSBudWxsID8gdm9pZCAwIDogc3VibWl0dGVyLmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikpIHx8IG1ldGhvZDtcbiAgICBzdWJtaXQoc3VibWl0dGVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcbiAgICAgIG1ldGhvZDogc3VibWl0TWV0aG9kLFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHJlbGF0aXZlLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgIGFjdGlvbjogZm9ybUFjdGlvbixcbiAgICBvblN1Ym1pdDogcmVsb2FkRG9jdW1lbnQgPyBvblN1Ym1pdCA6IHN1Ym1pdEhhbmRsZXJcbiAgfSwgcHJvcHMpKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEZvcm1JbXBsLmRpc3BsYXlOYW1lID0gXCJGb3JtSW1wbFwiO1xufVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCB3aWxsIGVtdWxhdGUgdGhlIGJyb3dzZXIncyBzY3JvbGwgcmVzdG9yYXRpb24gb24gbG9jYXRpb25cbiAqIGNoYW5nZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBTY3JvbGxSZXN0b3JhdGlvbihfcmVmNykge1xuICBsZXQge1xuICAgIGdldEtleSxcbiAgICBzdG9yYWdlS2V5XG4gIH0gPSBfcmVmNztcbiAgdXNlU2Nyb2xsUmVzdG9yYXRpb24oe1xuICAgIGdldEtleSxcbiAgICBzdG9yYWdlS2V5XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBTY3JvbGxSZXN0b3JhdGlvbi5kaXNwbGF5TmFtZSA9IFwiU2Nyb2xsUmVzdG9yYXRpb25cIjtcbn0gLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIEhvb2tzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBEYXRhUm91dGVySG9vaztcblxuKGZ1bmN0aW9uIChEYXRhUm91dGVySG9vaykge1xuICBEYXRhUm91dGVySG9va1tcIlVzZVNjcm9sbFJlc3RvcmF0aW9uXCJdID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZVN1Ym1pdEltcGxcIl0gPSBcInVzZVN1Ym1pdEltcGxcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VGZXRjaGVyXCJdID0gXCJ1c2VGZXRjaGVyXCI7XG59KShEYXRhUm91dGVySG9vayB8fCAoRGF0YVJvdXRlckhvb2sgPSB7fSkpO1xuXG52YXIgRGF0YVJvdXRlclN0YXRlSG9vaztcblxuKGZ1bmN0aW9uIChEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VGZXRjaGVyc1wiXSA9IFwidXNlRmV0Y2hlcnNcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVNjcm9sbFJlc3RvcmF0aW9uXCJdID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiO1xufSkoRGF0YVJvdXRlclN0YXRlSG9vayB8fCAoRGF0YVJvdXRlclN0YXRlSG9vayA9IHt9KSk7XG5cbmZ1bmN0aW9uIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpIHtcbiAgcmV0dXJuIGhvb2tOYW1lICsgXCIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGRhdGEgcm91dGVyLiAgU2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlcnMvcGlja2luZy1hLXJvdXRlci5cIjtcbn1cblxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0KTtcbiAgIWN0eCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gY3R4O1xufVxuXG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCk7XG4gICFzdGF0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gc3RhdGU7XG59XG4vKipcbiAqIEhhbmRsZXMgdGhlIGNsaWNrIGJlaGF2aW9yIGZvciByb3V0ZXIgYDxMaW5rPmAgY29tcG9uZW50cy4gVGhpcyBpcyB1c2VmdWwgaWZcbiAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBjdXN0b20gYDxMaW5rPmAgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGNsaWNrIGJlaGF2aW9yIHdlXG4gKiB1c2UgaW4gb3VyIGV4cG9ydGVkIGA8TGluaz5gLlxuICovXG5cblxuZnVuY3Rpb24gdXNlTGlua0NsaWNrSGFuZGxlcih0bywgX3RlbXApIHtcbiAgbGV0IHtcbiAgICB0YXJnZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZVByb3AsXG4gICAgc3RhdGUsXG4gICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICByZWxhdGl2ZVxuICB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAoc2hvdWxkUHJvY2Vzc0xpbmtDbGljayhldmVudCwgdGFyZ2V0KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gSWYgdGhlIFVSTCBoYXNuJ3QgY2hhbmdlZCwgYSByZWd1bGFyIDxhPiB3aWxsIGRvIGEgcmVwbGFjZSBpbnN0ZWFkIG9mXG4gICAgICAvLyBhIHB1c2gsIHNvIGRvIHRoZSBzYW1lIGhlcmUgdW5sZXNzIHRoZSByZXBsYWNlIHByb3AgaXMgZXhwbGljaXRseSBzZXRcblxuICAgICAgbGV0IHJlcGxhY2UgPSByZXBsYWNlUHJvcCAhPT0gdW5kZWZpbmVkID8gcmVwbGFjZVByb3AgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcbiAgICAgIG5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHJlbGF0aXZlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtsb2NhdGlvbiwgbmF2aWdhdGUsIHBhdGgsIHJlcGxhY2VQcm9wLCBzdGF0ZSwgdGFyZ2V0LCB0bywgcHJldmVudFNjcm9sbFJlc2V0LCByZWxhdGl2ZV0pO1xufVxuLyoqXG4gKiBBIGNvbnZlbmllbnQgd3JhcHBlciBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBzZWFyY2ggcGFyYW1ldGVycyB2aWEgdGhlXG4gKiBVUkxTZWFyY2hQYXJhbXMgaW50ZXJmYWNlLlxuICovXG5cbmZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyh0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLCBcIllvdSBjYW5ub3QgdXNlIHRoZSBgdXNlU2VhcmNoUGFyYW1zYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IFwiICsgXCJzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IFwiICsgXCJFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBcIiArIFwiaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuXCIgKyBcIklmIHlvdSdyZSB1bnN1cmUgaG93IHRvIGxvYWQgcG9seWZpbGxzLCB3ZSByZWNvbW1lbmQgeW91IGNoZWNrIG91dCBcIiArIFwiaHR0cHM6Ly9wb2x5ZmlsbC5pby92My8gd2hpY2ggcHJvdmlkZXMgc29tZSByZWNvbW1lbmRhdGlvbnMgYWJvdXQgaG93IFwiICsgXCJ0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgXCIgKyBcInVzZXIuXCIpIDogdm9pZCAwO1xuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgbGV0IGhhc1NldFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IC8vIE9ubHkgbWVyZ2UgaW4gdGhlIGRlZmF1bHRzIGlmIHdlIGhhdmVuJ3QgeWV0IGNhbGxlZCBzZXRTZWFyY2hQYXJhbXMuXG4gIC8vIE9uY2Ugd2UgY2FsbCB0aGF0IHdlIHdhbnQgdGhvc2UgdG8gdGFrZSBwcmVjZWRlbmNlLCBvdGhlcndpc2UgeW91IGNhbid0XG4gIC8vIHJlbW92ZSBhIHBhcmFtIHdpdGggc2V0U2VhcmNoUGFyYW1zKHt9KSBpZiBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZVxuICBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvbi5zZWFyY2gsIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID8gbnVsbCA6IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCksIFtsb2NhdGlvbi5zZWFyY2hdKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHNldFNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXh0SW5pdCwgbmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgbmV3U2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKHR5cGVvZiBuZXh0SW5pdCA9PT0gXCJmdW5jdGlvblwiID8gbmV4dEluaXQoc2VhcmNoUGFyYW1zKSA6IG5leHRJbml0KTtcbiAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgbmF2aWdhdGUoXCI/XCIgKyBuZXdTZWFyY2hQYXJhbXMsIG5hdmlnYXRlT3B0aW9ucyk7XG4gIH0sIFtuYXZpZ2F0ZSwgc2VhcmNoUGFyYW1zXSk7XG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gKiBzb21lIGFyYml0cmFyeSBkYXRhKSB0byB0aGUgc2VydmVyLlxuICovXG5cbmZ1bmN0aW9uIHVzZVN1Ym1pdCgpIHtcbiAgcmV0dXJuIHVzZVN1Ym1pdEltcGwoKTtcbn1cblxuZnVuY3Rpb24gdXNlU3VibWl0SW1wbChmZXRjaGVyS2V5LCBmZXRjaGVyUm91dGVJZCkge1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlU3VibWl0SW1wbCk7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX05hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IGN1cnJlbnRSb3V0ZUlkID0gVU5TQUZFX3VzZVJvdXRlSWQoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGFyZSBjYWxsaW5nIHN1Ym1pdCBkdXJpbmcgdGhlIHNlcnZlciByZW5kZXIuIFwiICsgXCJUcnkgY2FsbGluZyBzdWJtaXQgd2l0aGluIGEgYHVzZUVmZmVjdGAgb3IgY2FsbGJhY2sgaW5zdGVhZC5cIik7XG4gICAgfVxuXG4gICAgbGV0IHtcbiAgICAgIGFjdGlvbixcbiAgICAgIG1ldGhvZCxcbiAgICAgIGVuY1R5cGUsXG4gICAgICBmb3JtRGF0YVxuICAgIH0gPSBnZXRGb3JtU3VibWlzc2lvbkluZm8odGFyZ2V0LCBvcHRpb25zLCBiYXNlbmFtZSk7IC8vIEJhc2Ugb3B0aW9ucyBzaGFyZWQgYmV0d2VlbiBmZXRjaCgpIGFuZCBuYXZpZ2F0ZSgpXG5cbiAgICBsZXQgb3B0cyA9IHtcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0aW9ucy5wcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGZvcm1NZXRob2Q6IG1ldGhvZCxcbiAgICAgIGZvcm1FbmNUeXBlOiBlbmNUeXBlXG4gICAgfTtcblxuICAgIGlmIChmZXRjaGVyS2V5KSB7XG4gICAgICAhKGZldGNoZXJSb3V0ZUlkICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJObyByb3V0ZUlkIGF2YWlsYWJsZSBmb3IgdXNlRmV0Y2hlcigpXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICByb3V0ZXIuZmV0Y2goZmV0Y2hlcktleSwgZmV0Y2hlclJvdXRlSWQsIGFjdGlvbiwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZShhY3Rpb24sIF9leHRlbmRzKHt9LCBvcHRzLCB7XG4gICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgZnJvbVJvdXRlSWQ6IGN1cnJlbnRSb3V0ZUlkXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbcm91dGVyLCBiYXNlbmFtZSwgZmV0Y2hlcktleSwgZmV0Y2hlclJvdXRlSWQsIGN1cnJlbnRSb3V0ZUlkXSk7XG59IC8vIHY3OiBFdmVudHVhbGx5IHdlIHNob3VsZCBkZXByZWNhdGUgdGhpcyBlbnRpcmVseSBpbiBmYXZvciBvZiB1c2luZyB0aGVcbi8vIHJvdXRlciBtZXRob2QgZGlyZWN0bHk/XG5cblxuZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihhY3Rpb24sIF90ZW1wMikge1xuICBsZXQge1xuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCByb3V0ZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9Sb3V0ZUNvbnRleHQpO1xuICAhcm91dGVDb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGb3JtQWN0aW9uIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IFttYXRjaF0gPSByb3V0ZUNvbnRleHQubWF0Y2hlcy5zbGljZSgtMSk7IC8vIFNoYWxsb3cgY2xvbmUgcGF0aCBzbyB3ZSBjYW4gbW9kaWZ5IGl0IGJlbG93LCBvdGhlcndpc2Ugd2UgbW9kaWZ5IHRoZVxuICAvLyBvYmplY3QgcmVmZXJlbmNlZCBieSB1c2VNZW1vIGluc2lkZSB1c2VSZXNvbHZlZFBhdGhcblxuICBsZXQgcGF0aCA9IF9leHRlbmRzKHt9LCB1c2VSZXNvbHZlZFBhdGgoYWN0aW9uID8gYWN0aW9uIDogXCIuXCIsIHtcbiAgICByZWxhdGl2ZVxuICB9KSk7IC8vIFByZXZpb3VzbHkgd2Ugc2V0IHRoZSBkZWZhdWx0IGFjdGlvbiB0byBcIi5cIi4gVGhlIHByb2JsZW0gd2l0aCB0aGlzIGlzIHRoYXRcbiAgLy8gYHVzZVJlc29sdmVkUGF0aChcIi5cIilgIGV4Y2x1ZGVzIHNlYXJjaCBwYXJhbXMgYW5kIHRoZSBoYXNoIG9mIHRoZSByZXNvbHZlZFxuICAvLyBVUkwuIFRoaXMgaXMgdGhlIGludGVuZGVkIGJlaGF2aW9yIG9mIHdoZW4gXCIuXCIgaXMgc3BlY2lmaWNhbGx5IHByb3ZpZGVkIGFzXG4gIC8vIHRoZSBmb3JtIGFjdGlvbiwgYnV0IGluY29uc2lzdGVudCB3LyBicm93c2VycyB3aGVuIHRoZSBhY3Rpb24gaXMgb21pdHRlZC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG5cblxuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuXG4gIGlmIChhY3Rpb24gPT0gbnVsbCkge1xuICAgIC8vIFNhZmUgdG8gd3JpdGUgdG8gdGhlc2UgZGlyZWN0bHkgaGVyZSBzaW5jZSBpZiBhY3Rpb24gd2FzIHVuZGVmaW5lZCwgd2VcbiAgICAvLyB3b3VsZCBoYXZlIGNhbGxlZCB1c2VSZXNvbHZlZFBhdGgoXCIuXCIpIHdoaWNoIHdpbGwgbmV2ZXIgaW5jbHVkZSBhIHNlYXJjaFxuICAgIC8vIG9yIGhhc2hcbiAgICBwYXRoLnNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICBwYXRoLmhhc2ggPSBsb2NhdGlvbi5oYXNoOyAvLyBXaGVuIGdyYWJiaW5nIHNlYXJjaCBwYXJhbXMgZnJvbSB0aGUgVVJMLCByZW1vdmUgdGhlIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBpbnNlcnRlZCA/aW5kZXggcGFyYW0gc28gd2UgbWF0Y2ggdGhlIHVzZVJlc29sdmVkUGF0aCBzZWFyY2ggYmVoYXZpb3JcbiAgICAvLyB3aGljaCB3b3VsZCBub3QgaW5jbHVkZSA/aW5kZXhcblxuICAgIGlmIChtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aC5zZWFyY2gpO1xuICAgICAgcGFyYW1zLmRlbGV0ZShcImluZGV4XCIpO1xuICAgICAgcGF0aC5zZWFyY2ggPSBwYXJhbXMudG9TdHJpbmcoKSA/IFwiP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgIH1cbiAgfVxuXG4gIGlmICgoIWFjdGlvbiB8fCBhY3Rpb24gPT09IFwiLlwiKSAmJiBtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfSAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gIC8vIHRvIGNyZWF0aW5nIHRoZSBmb3JtIGFjdGlvbi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2VcbiAgLy8gdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlXG4gIC8vIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBhY3Rpb25zXG5cblxuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hlckZvcm0oZmV0Y2hlcktleSwgcm91dGVJZCkge1xuICBsZXQgRmV0Y2hlckZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtSW1wbCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICByZWY6IHJlZixcbiAgICAgIGZldGNoZXJLZXk6IGZldGNoZXJLZXksXG4gICAgICByb3V0ZUlkOiByb3V0ZUlkXG4gICAgfSkpO1xuICB9KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgRmV0Y2hlckZvcm0uZGlzcGxheU5hbWUgPSBcImZldGNoZXIuRm9ybVwiO1xuICB9XG5cbiAgcmV0dXJuIEZldGNoZXJGb3JtO1xufVxuXG5sZXQgZmV0Y2hlcklkID0gMDtcbi8qKlxuICogSW50ZXJhY3RzIHdpdGggcm91dGUgbG9hZGVycyBhbmQgYWN0aW9ucyB3aXRob3V0IGNhdXNpbmcgYSBuYXZpZ2F0aW9uLiBHcmVhdFxuICogZm9yIGFueSBpbnRlcmFjdGlvbiB0aGF0IHN0YXlzIG9uIHRoZSBzYW1lIHBhZ2UuXG4gKi9cblxuZnVuY3Rpb24gdXNlRmV0Y2hlcigpIHtcbiAgdmFyIF9yb3V0ZSRtYXRjaGVzO1xuXG4gIGxldCB7XG4gICAgcm91dGVyXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VGZXRjaGVyKTtcbiAgbGV0IHJvdXRlID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfUm91dGVDb250ZXh0KTtcbiAgIXJvdXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGZXRjaGVyIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHJvdXRlSWQgPSAoX3JvdXRlJG1hdGNoZXMgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGUkbWF0Y2hlcy5yb3V0ZS5pZDtcbiAgIShyb3V0ZUlkICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGZXRjaGVyIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcXFwiaWRcXFwiXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCBbZmV0Y2hlcktleV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBTdHJpbmcoKytmZXRjaGVySWQpKTtcbiAgbGV0IFtGb3JtXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAhcm91dGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIuRm9ybSgpXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGNyZWF0ZUZldGNoZXJGb3JtKGZldGNoZXJLZXksIHJvdXRlSWQpO1xuICB9KTtcbiAgbGV0IFtsb2FkXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGhyZWYgPT4ge1xuICAgICFyb3V0ZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIk5vIHJvdXRlciBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgIXJvdXRlSWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIk5vIHJvdXRlSWQgYXZhaWxhYmxlIGZvciBmZXRjaGVyLmxvYWQoKVwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHJvdXRlci5mZXRjaChmZXRjaGVyS2V5LCByb3V0ZUlkLCBocmVmKTtcbiAgfSk7XG4gIGxldCBzdWJtaXQgPSB1c2VTdWJtaXRJbXBsKGZldGNoZXJLZXksIHJvdXRlSWQpO1xuICBsZXQgZmV0Y2hlciA9IHJvdXRlci5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICBsZXQgZmV0Y2hlcldpdGhDb21wb25lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiBfZXh0ZW5kcyh7XG4gICAgRm9ybSxcbiAgICBzdWJtaXQsXG4gICAgbG9hZFxuICB9LCBmZXRjaGVyKSwgW2ZldGNoZXIsIEZvcm0sIHN1Ym1pdCwgbG9hZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElzIHRoaXMgYnVzdGVkIHdoZW4gdGhlIFJlYWN0IHRlYW0gZ2V0cyByZWFsIHdlaXJkIGFuZCBjYWxscyBlZmZlY3RzXG4gICAgLy8gdHdpY2Ugb24gbW91bnQ/ICBXZSByZWFsbHkganVzdCBuZWVkIHRvIGdhcmJhZ2UgY29sbGVjdCBoZXJlIHdoZW4gdGhpc1xuICAgIC8vIGZldGNoZXIgaXMgbm8gbG9uZ2VyIGFyb3VuZC5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gcm91dGVyIGF2YWlsYWJsZSB0byBjbGVhbiB1cCBmcm9tIHVzZUZldGNoZXIoKVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICB9O1xuICB9LCBbcm91dGVyLCBmZXRjaGVyS2V5XSk7XG4gIHJldHVybiBmZXRjaGVyV2l0aENvbXBvbmVudHM7XG59XG4vKipcbiAqIFByb3ZpZGVzIGFsbCBmZXRjaGVycyBjdXJyZW50bHkgb24gdGhlIHBhZ2UuIFVzZWZ1bCBmb3IgbGF5b3V0cyBhbmQgcGFyZW50XG4gKiByb3V0ZXMgdGhhdCBuZWVkIHRvIHByb3ZpZGUgcGVuZGluZy9vcHRpbWlzdGljIFVJIHJlZ2FyZGluZyB0aGUgZmV0Y2guXG4gKi9cblxuZnVuY3Rpb24gdXNlRmV0Y2hlcnMoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXJzKTtcbiAgcmV0dXJuIFsuLi5zdGF0ZS5mZXRjaGVycy52YWx1ZXMoKV07XG59XG5jb25zdCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkgPSBcInJlYWN0LXJvdXRlci1zY3JvbGwtcG9zaXRpb25zXCI7XG5sZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSB7fTtcbi8qKlxuICogV2hlbiByZW5kZXJlZCBpbnNpZGUgYSBSb3V0ZXJQcm92aWRlciwgd2lsbCByZXN0b3JlIHNjcm9sbCBwb3NpdGlvbnMgb24gbmF2aWdhdGlvbnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbihfdGVtcDMpIHtcbiAgbGV0IHtcbiAgICBnZXRLZXksXG4gICAgc3RvcmFnZUtleVxuICB9ID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMztcbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVNjcm9sbFJlc3RvcmF0aW9uKTtcbiAgbGV0IHtcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb24sXG4gICAgcHJldmVudFNjcm9sbFJlc2V0XG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VTY3JvbGxSZXN0b3JhdGlvbik7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBtYXRjaGVzID0gdXNlTWF0Y2hlcygpO1xuICBsZXQgbmF2aWdhdGlvbiA9IHVzZU5hdmlnYXRpb24oKTsgLy8gVHJpZ2dlciBtYW51YWwgc2Nyb2xsIHJlc3RvcmF0aW9uIHdoaWxlIHdlJ3JlIGFjdGl2ZVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICAgIH07XG4gIH0sIFtdKTsgLy8gU2F2ZSBwb3NpdGlvbnMgb24gcGFnZWhpZGVcblxuICB1c2VQYWdlSGlkZShSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKG5hdmlnYXRpb24uc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICBsZXQga2V5ID0gKGdldEtleSA/IGdldEtleShsb2NhdGlvbiwgbWF0Y2hlcykgOiBudWxsKSB8fCBsb2NhdGlvbi5rZXk7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldID0gd2luZG93LnNjcm9sbFk7XG4gICAgfVxuXG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yYWdlS2V5IHx8IFNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoc2F2ZWRTY3JvbGxQb3NpdGlvbnMpKTtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICB9LCBbc3RvcmFnZUtleSwgZ2V0S2V5LCBuYXZpZ2F0aW9uLnN0YXRlLCBsb2NhdGlvbiwgbWF0Y2hlc10pKTsgLy8gUmVhZCBpbiBhbnkgc2F2ZWQgc2Nyb2xsIGxvY2F0aW9uc1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHNlc3Npb25Qb3NpdGlvbnMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkgfHwgU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZKTtcblxuICAgICAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkgey8vIG5vLW9wLCB1c2UgZGVmYXVsdCBlbXB0eSBvYmplY3RcbiAgICAgIH1cbiAgICB9LCBbc3RvcmFnZUtleV0pOyAvLyBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGluIHRoZSByb3V0ZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcblxuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXIuZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oc2F2ZWRTY3JvbGxQb3NpdGlvbnMsICgpID0+IHdpbmRvdy5zY3JvbGxZLCBnZXRLZXkpO1xuICAgICAgcmV0dXJuICgpID0+IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiAmJiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgICB9LCBbcm91dGVyLCBnZXRLZXldKTsgLy8gUmVzdG9yZSBzY3JvbGxpbmcgd2hlbiBzdGF0ZS5yZXN0b3JlU2Nyb2xsUG9zaXRpb24gY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIEV4cGxpY2l0IGZhbHNlIG1lYW5zIGRvbid0IGRvIGFueXRoaW5nICh1c2VkIGZvciBzdWJtaXNzaW9ucylcbiAgICAgIGlmIChyZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gYmVlbiBoZXJlIGJlZm9yZSwgc2Nyb2xsIHRvIGl0XG5cblxuICAgICAgaWYgKHR5cGVvZiByZXN0b3JlU2Nyb2xsUG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHJlc3RvcmVTY3JvbGxQb3NpdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gdHJ5IHRvIHNjcm9sbCB0byB0aGUgaGFzaFxuXG5cbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxvY2F0aW9uLmhhc2guc2xpY2UoMSkpO1xuXG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgIGVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIERvbid0IHJlc2V0IGlmIHRoaXMgbmF2aWdhdGlvbiBvcHRlZCBvdXRcblxuXG4gICAgICBpZiAocHJldmVudFNjcm9sbFJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuXG5cbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb24sIHJlc3RvcmVTY3JvbGxQb3NpdGlvbiwgcHJldmVudFNjcm9sbFJlc2V0XSk7XG4gIH1cbn1cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYGJlZm9yZXVubG9hZGAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcy5cbiAqXG4gKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VCZWZvcmVVbmxvYWQoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBjYXB0dXJlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8ge1xuICAgICAgY2FwdHVyZVxuICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfTtcbiAgfSwgW2NhbGxiYWNrLCBjYXB0dXJlXSk7XG59XG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBwYWdlaGlkZWAgZXZlbnQuIFRoaXMgaXNcbiAqIHVzZWZ1bCBmb3Igc2F2aW5nIHNvbWUgZGF0YSB0byBgd2luZG93LmxvY2FsU3RvcmFnZWAganVzdCBiZWZvcmUgdGhlIHBhZ2VcbiAqIHJlZnJlc2hlcy4gIFRoaXMgZXZlbnQgaXMgYmV0dGVyIHN1cHBvcnRlZCB0aGFuIGJlZm9yZXVubG9hZCBhY3Jvc3MgYnJvd3NlcnMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlUGFnZUhpZGUoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBjYXB0dXJlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8ge1xuICAgICAgY2FwdHVyZVxuICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCB1c2VCbG9ja2VyIHRvIHNob3cgYSB3aW5kb3cuY29uZmlybSBwcm9tcHQgdG8gdXNlcnMgaW5zdGVhZFxuICogb2YgYnVpbGRpbmcgYSBjdXN0b20gVUkgd2l0aCB1c2VCbG9ja2VyLlxuICpcbiAqIFdhcm5pbmc6IFRoaXMgaGFzICphIGxvdCBvZiByb3VnaCBlZGdlcyogYW5kIGJlaGF2ZXMgdmVyeSBkaWZmZXJlbnRseSAoYW5kXG4gKiB2ZXJ5IGluY29ycmVjdGx5IGluIHNvbWUgY2FzZXMpIGFjcm9zcyBicm93c2VycyBpZiB1c2VyIGNsaWNrIGFkZGl0aW9uXG4gKiBiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbnMgd2hpbGUgdGhlIGNvbmZpcm0gaXMgb3Blbi4gIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICovXG5cblxuZnVuY3Rpb24gdXNlUHJvbXB0KF9yZWY4KSB7XG4gIGxldCB7XG4gICAgd2hlbixcbiAgICBtZXNzYWdlXG4gIH0gPSBfcmVmODtcbiAgbGV0IGJsb2NrZXIgPSB1bnN0YWJsZV91c2VCbG9ja2VyKHdoZW4pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgIGxldCBwcm9jZWVkID0gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG5cbiAgICAgIGlmIChwcm9jZWVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQoYmxvY2tlci5wcm9jZWVkLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrZXIucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtibG9ja2VyLCBtZXNzYWdlXSk7XG59XG4gLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEJyb3dzZXJSb3V0ZXIsIEZvcm0sIEhhc2hSb3V0ZXIsIExpbmssIE5hdkxpbmssIFNjcm9sbFJlc3RvcmF0aW9uLCB1c2VTY3JvbGxSZXN0b3JhdGlvbiBhcyBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24sIGNyZWF0ZUJyb3dzZXJSb3V0ZXIsIGNyZWF0ZUhhc2hSb3V0ZXIsIGNyZWF0ZVNlYXJjaFBhcmFtcywgSGlzdG9yeVJvdXRlciBhcyB1bnN0YWJsZV9IaXN0b3J5Um91dGVyLCB1c2VQcm9tcHQgYXMgdW5zdGFibGVfdXNlUHJvbXB0LCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMaW5rQ2xpY2tIYW5kbGVyLCB1c2VTZWFyY2hQYXJhbXMsIHVzZVN1Ym1pdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzIiwiUm91dGVyIiwiVU5TQUZFX05hdmlnYXRpb25Db250ZXh0IiwidXNlSHJlZiIsInVzZVJlc29sdmVkUGF0aCIsInVzZUxvY2F0aW9uIiwiVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJ1c2VOYXZpZ2F0ZSIsImNyZWF0ZVBhdGgiLCJVTlNBRkVfdXNlUm91dGVJZCIsIlVOU0FGRV9Sb3V0ZUNvbnRleHQiLCJ1c2VNYXRjaGVzIiwidXNlTmF2aWdhdGlvbiIsInVuc3RhYmxlX3VzZUJsb2NrZXIiLCJVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsIkF3YWl0IiwiTWVtb3J5Um91dGVyIiwiTmF2aWdhdGUiLCJOYXZpZ2F0aW9uVHlwZSIsIk91dGxldCIsIlJvdXRlIiwiUm91dGVyUHJvdmlkZXIiLCJSb3V0ZXMiLCJVTlNBRkVfTG9jYXRpb25Db250ZXh0IiwiY3JlYXRlTWVtb3J5Um91dGVyIiwiY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIiwiY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzIiwiZGVmZXIiLCJnZW5lcmF0ZVBhdGgiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsImpzb24iLCJtYXRjaFBhdGgiLCJtYXRjaFJvdXRlcyIsInBhcnNlUGF0aCIsInJlZGlyZWN0IiwicmVuZGVyTWF0Y2hlcyIsInJlc29sdmVQYXRoIiwidXNlQWN0aW9uRGF0YSIsInVzZUFzeW5jRXJyb3IiLCJ1c2VBc3luY1ZhbHVlIiwidXNlSW5Sb3V0ZXJDb250ZXh0IiwidXNlTG9hZGVyRGF0YSIsInVzZU1hdGNoIiwidXNlTmF2aWdhdGlvblR5cGUiLCJ1c2VPdXRsZXQiLCJ1c2VPdXRsZXRDb250ZXh0IiwidXNlUGFyYW1zIiwidXNlUmV2YWxpZGF0b3IiLCJ1c2VSb3V0ZUVycm9yIiwidXNlUm91dGVMb2FkZXJEYXRhIiwidXNlUm91dGVzIiwic3RyaXBCYXNlbmFtZSIsImNyZWF0ZVJvdXRlciIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJFcnJvclJlc3BvbnNlIiwiVU5TQUZFX3dhcm5pbmciLCJVTlNBRkVfaW52YXJpYW50Iiwiam9pblBhdGhzIiwiX2V4dGVuZHMiLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJrZXlzIiwiaW5kZXhPZiIsImRlZmF1bHRNZXRob2QiLCJkZWZhdWx0RW5jVHlwZSIsImlzSHRtbEVsZW1lbnQiLCJvYmplY3QiLCJ0YWdOYW1lIiwiaXNCdXR0b25FbGVtZW50IiwidG9Mb3dlckNhc2UiLCJpc0Zvcm1FbGVtZW50IiwiaXNJbnB1dEVsZW1lbnQiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsIm1ldGFLZXkiLCJhbHRLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJzaG91bGRQcm9jZXNzTGlua0NsaWNrIiwiYnV0dG9uIiwiY3JlYXRlU2VhcmNoUGFyYW1zIiwiaW5pdCIsIlVSTFNlYXJjaFBhcmFtcyIsIkFycmF5IiwiaXNBcnJheSIsInJlZHVjZSIsIm1lbW8iLCJ2YWx1ZSIsImNvbmNhdCIsIm1hcCIsInYiLCJnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbiIsImxvY2F0aW9uU2VhcmNoIiwiZGVmYXVsdFNlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtcyIsImhhcyIsImdldEFsbCIsImZvckVhY2giLCJhcHBlbmQiLCJnZXRGb3JtU3VibWlzc2lvbkluZm8iLCJvcHRpb25zIiwiYmFzZW5hbWUiLCJtZXRob2QiLCJhY3Rpb24iLCJlbmNUeXBlIiwiZm9ybURhdGEiLCJzdWJtaXNzaW9uVHJpZ2dlciIsImF0dHIiLCJnZXRBdHRyaWJ1dGUiLCJGb3JtRGF0YSIsIm5hbWUiLCJ0eXBlIiwiZm9ybSIsIkVycm9yIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIl9leGNsdWRlZDMiLCJjcmVhdGVCcm93c2VyUm91dGVyIiwicm91dGVzIiwib3B0cyIsImZ1dHVyZSIsInY3X3ByZXBlbmRCYXNlbmFtZSIsImhpc3RvcnkiLCJ3aW5kb3ciLCJoeWRyYXRpb25EYXRhIiwicGFyc2VIeWRyYXRpb25EYXRhIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwiaW5pdGlhbGl6ZSIsImNyZWF0ZUhhc2hSb3V0ZXIiLCJfd2luZG93Iiwic3RhdGUiLCJfX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGEiLCJlcnJvcnMiLCJkZXNlcmlhbGl6ZUVycm9ycyIsImVudHJpZXMiLCJzZXJpYWxpemVkIiwidmFsIiwiX190eXBlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImRhdGEiLCJpbnRlcm5hbCIsImVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwiQnJvd3NlclJvdXRlciIsIl9yZWYiLCJjaGlsZHJlbiIsImhpc3RvcnlSZWYiLCJ1c2VSZWYiLCJjdXJyZW50IiwidjVDb21wYXQiLCJzZXRTdGF0ZSIsInVzZVN0YXRlIiwibG9jYXRpb24iLCJ1c2VMYXlvdXRFZmZlY3QiLCJsaXN0ZW4iLCJjcmVhdGVFbGVtZW50IiwibmF2aWdhdGlvblR5cGUiLCJuYXZpZ2F0b3IiLCJIYXNoUm91dGVyIiwiX3JlZjIiLCJIaXN0b3J5Um91dGVyIiwiX3JlZjMiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiLCJpc0Jyb3dzZXIiLCJkb2N1bWVudCIsIkFCU09MVVRFX1VSTF9SRUdFWCIsIkxpbmsiLCJmb3J3YXJkUmVmIiwiTGlua1dpdGhSZWYiLCJfcmVmNCIsInJlZiIsIm9uQ2xpY2siLCJyZWxhdGl2ZSIsInJlbG9hZERvY3VtZW50IiwicmVwbGFjZSIsInRvIiwicHJldmVudFNjcm9sbFJlc2V0IiwicmVzdCIsInVzZUNvbnRleHQiLCJhYnNvbHV0ZUhyZWYiLCJpc0V4dGVybmFsIiwidGVzdCIsImN1cnJlbnRVcmwiLCJVUkwiLCJocmVmIiwidGFyZ2V0VXJsIiwic3RhcnRzV2l0aCIsInByb3RvY29sIiwicGF0aCIsInBhdGhuYW1lIiwib3JpZ2luIiwic2VhcmNoIiwiaGFzaCIsImUiLCJpbnRlcm5hbE9uQ2xpY2siLCJ1c2VMaW5rQ2xpY2tIYW5kbGVyIiwiaGFuZGxlQ2xpY2siLCJkZWZhdWx0UHJldmVudGVkIiwiTmF2TGluayIsIk5hdkxpbmtXaXRoUmVmIiwiX3JlZjUiLCJhcmlhQ3VycmVudFByb3AiLCJjYXNlU2Vuc2l0aXZlIiwiY2xhc3NOYW1lIiwiY2xhc3NOYW1lUHJvcCIsImVuZCIsInN0eWxlIiwic3R5bGVQcm9wIiwicm91dGVyU3RhdGUiLCJ0b1BhdGhuYW1lIiwiZW5jb2RlTG9jYXRpb24iLCJsb2NhdGlvblBhdGhuYW1lIiwibmV4dExvY2F0aW9uUGF0aG5hbWUiLCJuYXZpZ2F0aW9uIiwiaXNBY3RpdmUiLCJjaGFyQXQiLCJpc1BlbmRpbmciLCJhcmlhQ3VycmVudCIsInVuZGVmaW5lZCIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiRm9ybSIsInByb3BzIiwiRm9ybUltcGwiLCJfcmVmNiIsImZvcndhcmRlZFJlZiIsIm9uU3VibWl0IiwiZmV0Y2hlcktleSIsInJvdXRlSWQiLCJzdWJtaXQiLCJ1c2VTdWJtaXRJbXBsIiwiZm9ybU1ldGhvZCIsImZvcm1BY3Rpb24iLCJ1c2VGb3JtQWN0aW9uIiwic3VibWl0SGFuZGxlciIsInByZXZlbnREZWZhdWx0Iiwic3VibWl0dGVyIiwibmF0aXZlRXZlbnQiLCJzdWJtaXRNZXRob2QiLCJjdXJyZW50VGFyZ2V0IiwiU2Nyb2xsUmVzdG9yYXRpb24iLCJfcmVmNyIsImdldEtleSIsInN0b3JhZ2VLZXkiLCJ1c2VTY3JvbGxSZXN0b3JhdGlvbiIsIkRhdGFSb3V0ZXJIb29rIiwiRGF0YVJvdXRlclN0YXRlSG9vayIsImdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IiLCJob29rTmFtZSIsInVzZURhdGFSb3V0ZXJDb250ZXh0IiwiY3R4IiwidXNlRGF0YVJvdXRlclN0YXRlIiwiX3RlbXAiLCJyZXBsYWNlUHJvcCIsIm5hdmlnYXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VTZWFyY2hQYXJhbXMiLCJkZWZhdWx0SW5pdCIsImRlZmF1bHRTZWFyY2hQYXJhbXNSZWYiLCJoYXNTZXRTZWFyY2hQYXJhbXNSZWYiLCJ1c2VNZW1vIiwic2V0U2VhcmNoUGFyYW1zIiwibmV4dEluaXQiLCJuYXZpZ2F0ZU9wdGlvbnMiLCJuZXdTZWFyY2hQYXJhbXMiLCJ1c2VTdWJtaXQiLCJmZXRjaGVyUm91dGVJZCIsInJvdXRlciIsIlVzZVN1Ym1pdEltcGwiLCJjdXJyZW50Um91dGVJZCIsImZvcm1FbmNUeXBlIiwiZmV0Y2giLCJmcm9tUm91dGVJZCIsIl90ZW1wMiIsInJvdXRlQ29udGV4dCIsIm1hdGNoIiwibWF0Y2hlcyIsInNsaWNlIiwicm91dGUiLCJpbmRleCIsInBhcmFtcyIsImRlbGV0ZSIsInRvU3RyaW5nIiwiY3JlYXRlRmV0Y2hlckZvcm0iLCJGZXRjaGVyRm9ybSIsImZldGNoZXJJZCIsInVzZUZldGNoZXIiLCJfcm91dGUkbWF0Y2hlcyIsIlVzZUZldGNoZXIiLCJpZCIsIlN0cmluZyIsImxvYWQiLCJmZXRjaGVyIiwiZ2V0RmV0Y2hlciIsImZldGNoZXJXaXRoQ29tcG9uZW50cyIsInVzZUVmZmVjdCIsImNvbnNvbGUiLCJ3YXJuIiwiZGVsZXRlRmV0Y2hlciIsInVzZUZldGNoZXJzIiwiVXNlRmV0Y2hlcnMiLCJmZXRjaGVycyIsInZhbHVlcyIsIlNDUk9MTF9SRVNUT1JBVElPTl9TVE9SQUdFX0tFWSIsInNhdmVkU2Nyb2xsUG9zaXRpb25zIiwiX3RlbXAzIiwiVXNlU2Nyb2xsUmVzdG9yYXRpb24iLCJyZXN0b3JlU2Nyb2xsUG9zaXRpb24iLCJzY3JvbGxSZXN0b3JhdGlvbiIsInVzZVBhZ2VIaWRlIiwic2Nyb2xsWSIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXNzaW9uUG9zaXRpb25zIiwiZ2V0SXRlbSIsInBhcnNlIiwiZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uIiwiZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJzY3JvbGxUbyIsImVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsInVzZUJlZm9yZVVubG9hZCIsImNhbGxiYWNrIiwiY2FwdHVyZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXNlUHJvbXB0IiwiX3JlZjgiLCJ3aGVuIiwiYmxvY2tlciIsInJlc2V0IiwicHJvY2VlZCIsImNvbmZpcm0iLCJzZXRUaW1lb3V0IiwiVU5TQUZFX3VzZVNjcm9sbFJlc3RvcmF0aW9uIiwidW5zdGFibGVfSGlzdG9yeVJvdXRlciIsInVuc3RhYmxlX3VzZVByb21wdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../../node_modules/react-router-dom/dist/index.js\n");

/***/ })

};
;